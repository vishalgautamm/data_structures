{
  "name": "Data structures and algorithms",
  "tagline": "",
  "body": "# Data Structures\r\n\r\n\r\n## Stacks\r\n- An ordered collection of items that follow the LIFO (**Last In First Out**)\r\n- The beginning of the stack is known as **base** and the ending is known as **top**\r\n- First item entered is the base item and the last item is called the top item\r\n- Real life examples of stack include: stacks of books, stacks of plate from the kitchen.\r\n\r\n### Implementation of Stack in Javascript using ES6\r\n\r\n#### Creating a Stack\r\n\r\n**Step 1: Create a stack class**\r\n- We will create a Stack class using the ES6 Classes\r\n```javascript\r\nclass Stack {\r\n    \r\n};\r\n```\r\n\r\n**Step 2: Define a data structure that will store the elements of the stack**\r\n- For this we will define a constructor function that will contain our array. the array will \r\nstore all the elements of the Stack\r\n\r\n```javascript\r\nclass Stack {\r\n    constructor () {\r\n        this.item = [];\r\n    }\r\n};\r\n```\r\n**Step 3: Declare methods**\r\n- In this example we will declare the following methods\r\n1. **insert** : This method add new item into the to of the stack\r\n2. **remove** : Removes item from the top of the stack.\r\n3. **peek** : Returns the item from the top of the stack.\r\n4. **isEmpty** : Return true if the stack is empty. Otherwise returns false.\r\n5. **size** : Returns the number of elements contained in stack\r\n6. **clear**: Empties the stack\r\n7. **print** : Logs out the item contained in the stack\r\n8. **toString** : Returns all the items from the stack\r\n\r\n```javascript\r\n\r\nclass Stack {\r\n\r\n    constructor () {\r\n        this.item = [];\r\n    }\r\n    insert(element) {\r\n        this.item.push(element);\r\n    }\r\n    remove() {\r\n        return this.item.pop();\r\n    }\r\n    peek() {\r\n        return this.item[this.item.length - 1];\r\n    }\r\n\r\n    isEmpty() {\r\n        return (this.item.length === 0);\r\n    }\r\n\r\n    size() {\r\n        return this.item.length;\r\n    }\r\n\r\n    clear () {\r\n        this.item = [];\r\n    }\r\n\r\n    print() {\r\n        console.log(this.item.toString());\r\n    }\r\n\r\n    toString() {\r\n        return this.item.toString()\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Linked Lists\r\n\r\n - Linked lists store a sequential collection of elements\r\n - Each element consists of a node that stores the element itself and also a reference (also known as a pointer or link) that points to the next element.\r\n  \r\n## Binary Search Tree\r\n\r\n- A binary search tree is a binary tree, but it only allows you to store nodes with lesser values on the left side and nodes with greater values on the right side.\r\n  \r\n## Hash Table\r\n\r\n- Hashing consists of finding a value in a data structure in the shortest time possible.\r\n- When we use a hash function, we already know which position the value is in, so we can simply retrieve it.\r\n- A hash function is a function that given a key, and will return an address in the table where the value is.\r\n\r\n# Algorithms\r\n\r\n## Merge Sort\r\n\r\n###Pseudo Code\r\n- Recursively sort first half of the input array\r\n- Recursively sort second half of the input array\r\n- Merge two sorted sublists into one\r\n\r\n### Analysis: Running Time\r\n- The Merge Sort has a running time of N*log(N) \r\n\r\nHIGHLIGHTS BY 0",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}